{
id: "particle_attache_slicer",
prototype: ["effects_attache"],
zorder: "@include data/zorder.cfg:near_player_foreground_effects",
always_active: true,


properties: {
	child_systems: "
		map(
			range(dump(child_system_count)),
			object('particle_attache', x,y, {
				_particle_type: _particle_type,
				parent: me,
				time_to_die: 0,
				x:x, y:y,
				zorder: me.zorder,
			})
		)",

	active_child_systems: "[obj particle_attache] :: filter(me._effects_attaches, value is obj particle_attache)",

#-------------------------- effects_attache overrides --------------------------#
	do_setup: "execute(me, [
					initialize_position,
					;
					if(size(active_child_systems) = 0, create_children)
				])",
	
	turn_off: "map(active_child_systems, value.turn_off)",
	turn_on: "map(active_child_systems, value.turn_on)",


	create_children: "execute(me, [
		map(child_systems, 'child', add_object(child)),

		;

		map(
			active_child_systems,
			[
				set(value.relative_x,  new_relative_x ),
				set(value.activation_border,  slice_width),
				set(value.activation_area, new_activation_rectangle ),
				set(value.clip_area, dump(new_clip_rectangle))
			]
				where new_activation_rectangle = [
					lib.math.round( me.mid_x - new_relative_x - water_width/2 ),
					lib.math.round( water_boundaries[1] ),
					lib.math.round( me.mid_x + new_relative_x + value.w/2 + 0 ),
					lib.math.round( water_boundaries[3] )
				]

				where new_clip_rectangle = /*[
					lib.math.round( me.mid_x - new_relative_x - value.w/2 - 0 ),
					lib.math.round( water_boundaries[0] - (me.mid_x) ),
					lib.math.round( me.mid_x + new_relative_x + value.w/2 + 0 ),
					lib.math.round( water_height )
				]*/

				[
					-(slice_width / 2), //water_boundaries[0]-mid_x,
					water_boundaries[1]-mid_y,
					(slice_width*1), //water_boundaries[2] - water_boundaries[0],
					water_boundaries[3] - water_boundaries[1]
				]
//				[water_boundaries[0]-mid_x, water_boundaries[1]-mid_y, water_boundaries[2] - water_boundaries[0], water_boundaries[3] - water_boundaries[1] ]


//			set(value.clip_area, [_x_bound-mid_x, _y_bound-mid_y, _x2_bound - _x_bound, _y2_bound - _y_bound, ]),


				where new_relative_x = (-(water_width / 2) + (slice_width * index) + (slice_width/2))
		),
	])",
#-------------------------- vars --------------------------#
	_particle_type: {
		type: "string",
		dynamic_initialization: true,
	},

	child_system_count: {
		type: "int",
		dynamic_initialization: true,
	},

	slice_width: {
		type: "int",
		dynamic_initialization: true,
	},

	water_height: {
		type: "int",
		dynamic_initialization: true,
	},

	water_width: {
		type: "int",
		dynamic_initialization: true,
	},

	water_boundaries: {
		type: "[int,int,int,int]",
		dynamic_initialization: true,
	},


}



}
